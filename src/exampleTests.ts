//import { NoopConnection } from "./clients/NoopConnection"
import { Table } from "./Table"
import { PostgreSqlConnection } from "./connections/PostgreSqlConnection"
import { ConsoleLogNoopQueryRunner } from "./queryRunners/ConsoleLogNoopQueryRunner"
import { View } from "./View"
import { ConsoleLogQueryRunner } from "./queryRunners/ConsoleLogQueryRunner"
import { NoopQueryRunner } from "./queryRunners/NoopQueryRunner"
import { TypeSafeMySqlConnection } from "./connections/TypeSafeMySqlConnection"
import { MockQueryRunner } from "./queryRunners/MockQueryRunner"
import { CustomBooleanTypeAdapter } from "./TypeAdapter"
import { DynamicCondition } from "./expressions/dynamicConditionUsingFilters"
import { dynamicPick } from "./dynamicCondition"
import { extractColumnsFrom, mapForGuidedSplit, mergeType, prefixCapitalized, prefixDotted, prefixMapForGuidedSplitCapitalized, prefixMapForGuidedSplitDotted, prefixMapForSplitCapitalized, prefixMapForSplitDotted } from "./extras/utils"
// import { InterceptorQueryRunner, QueryType } from "./queryRunners/InterceptorQueryRunner"
// import { TypeSafeNoopConnection } from "./clients/TypeSafeNoopConnection"
// import { int } from "ts-extended-types"

class MyConection extends PostgreSqlConnection<'MyConnection'> {
    procedure1(p1: number) {
        return this.executeProcedure('procedure1', [this.const(p1, 'int')])
    }
    function1(p1: number) {
        return this.executeFunction('function1', [this.const(p1, 'int')], 'int', 'required')
    }
    now = this.buildFragmentWithArgs().as(() => {
        return this.fragmentWithType('localDateTime', 'required').sql`now()`
    })

    isBigFactorial = this.buildFragmentWithArgs(
        this.arg('int', 'required'),
        this.arg('int', 'required')
    ).as((a1, a2) => {
        return this.fragmentWithType('boolean', 'required').sql`!!${a1} > ${a2}`
    })

    customIsNull = this.buildFragmentWithArgs(
        this.arg('boolean', 'optional')
    ).as((a1) => {
        return this.fragmentWithType('boolean', 'required').sql`${a1} is null`
    })

    transformValueFromDB(value: any, type: any) {
        if (type === 'json') {
            return JSON.parse(value);
        }
        return super.transformValueFromDB(value, type);
    }
    transformValueToDB(value: any, type: any) {
        if (type === 'json') {
            return JSON.stringify(value);
        }
        return super.transformValueToDB(value, type);
    }
}

class MyTable extends Table<MyConection, 'MyTable'> {
    id = this.autogeneratedPrimaryKeyBySequence('id', 'mySeq', 'int')
    c = this.column('c', 'int')
    d = this.column('d', 'string')
    e = this.columnWithDefaultValue('e', 'localDateTime')
    oc = this.optionalColumn('oc', 'int')
    od = this.optionalColumn('od', 'string')
    oe = this.optionalColumn('oe', 'localDateTime')
    bool = this.optionalColumn('bool', 'boolean')
    customBool = this.column('custom_boolean', 'boolean', new CustomBooleanTypeAdapter('t', 'f'))
    optCustomBool = this.optionalColumn('opt_custom_boolean', 'boolean', new CustomBooleanTypeAdapter('Y', 'N'))
    computed = this.computedColumn('computed', 'string')
    optComputed = this.optionalComputedColumn('opt_computed', 'string')
    constructor() {
        super('t')
    }
}

// interface DurationPlayload {
//     startTime: number
// }
// class DurationLogginQueryRunner extends InterceptorQueryRunner<DurationPlayload> {
//     onQuery(queryType: QueryType, query: string, params: any[]): DurationPlayload {
//         console.log('onQuery', queryType, query, params)
//         return { startTime: Date.now() }
//     }
//     onQueryResult(queryType: QueryType, query: string, params: any[], result: any, playload: DurationPlayload): void {
//         const duration = Date.now() - playload.startTime
//         console.log('onQueryResult', queryType, query, params, result, duration)
//     }
//     onQueryError(queryType: QueryType, query: string, params: any[], error: any, playload: DurationPlayload): void {
//         const duration = Date.now() - playload.startTime
//         console.log('onQueryError', queryType, query, params, error, duration)
//     }
// }

// declare var a: ColumnsOf<MyConection, MyTable>
// declare var aa: keyof MyTable

// declare var ate: TypeOfColumn<MyConection, MyTable, 'oe'>

let t = new MyTable()

// class MyConection2 extends NoopConnection<MyConection2, 'MyConection2'> {
// }
let q = new class MyTable2 extends Table<MyConection, 'MyTable2'> {
    f = this.column('f', 'int')
    g = this.optionalColumn('g', 'string')
    constructor() {
        super('q')
    }
}()
let cn = new MyConection(new ConsoleLogNoopQueryRunner())
cn.const(10, 'int')
let query = cn.insertInto(t)
    .set({ c: 10, d: '', oc: 20, bool: cn.true(), customBool: true }).setIfValue({ c: null, e: cn.default() })
    // .set(t.c).value(10)
    // .set(t.c).value(12)
    .ignoreIfSet('e').returningLastInsertedId()
console.log(query.query(), query.params())

const query0 = cn.insertInto(t)
    .from(
        cn.selectFrom(t)
        .where(
            t.bool
        )
        .select({
            c: t.c,
            d: t.d,
            bool: t.customBool,
            customBool: t.customBool,
            optCustomBool: t.customBool
        })
    )
console.log(query0.query(), query0.params())

// query = cn.insertInto(t).dynamicSet().set({ c: 10 }).set({d: ''})
// console.log(query.query(), query.params())

// query = cn.insertInto(q).defaultValues()
// console.log(query.query(), query.params())

let query1 = cn.updateAllowingNoWhere(t)
    .set({c: t.c, d: 'hola', e: new Date(), bool: t.bool.negate(), customBool: true})
    .set({ c: 11 })
    .set({ e: cn.default() })
    .ignoreIfSet('e')
    // .set(t.c).value(10)
    // .set(t.c).value(11)
console.log(query1.query(), query1.params())

//let m = t.c.power(10)
// let mm = t.c.power(cn.pi())
// let mm1 = t.c.power(mm)
// let mm2 = t.c.power(q.c)
// let mm3 = cn.pi().power(cn.pi()).equals(3)
// let mm4 = cn.const(3).power(10).lessOrEquals(mm1)

// let cond = mm1.greaterOrEquals(7).negate()

const di: any = {}
let where
where = cn.true()
if (di.a) {
    where = where.and(t.c.lessOrEquals(10))
}
if (!di.b) {
    where = where.and(t.c.lessThan(1))
}
where = where.and(t.c.equals(2))

let query2 = cn.update(t)
    .set({ c: t.c, bool: cn.true() })
    .where(where)
//    .where(t.c.greaterThan(10).and(t.c.greaterThan(1)))
    // .where(cn.pi().power(t.c).equals(3).and(t.c.greaterThan(10)))
//     .whereAnd(
//     cn.pi().power(t.c).equals(3),
//     t.c.greaterOrEquals(10)
// )

//    .set(t.c).value(t.c).where(cn.pi().power(t.c).equals(3))
console.log(query2.query(), query2.params())

q.f.abs()

let query3 = cn.update(t)
    .set({ d: 'hello' })
    .dynamicWhere()

query3 = query3.and(t.c.greaterOrEquals(10))
query3 = query3.and(t.d.equals('mm'))

console.log(query3.query(), query3.params())

let query4 = cn.deleteFrom(t)
    .dynamicWhere()

query4 = query4.and(t.c.greaterOrEquals(33))
query4 = query4.and(t.d.equals('zz'))

console.log(query4.query(), query4.params())

// import { Table, Column } from "./query"
// import { PostgreSqlConnection } from "./client/postgreSql/postgreSql"

// let t = new Table(undefined, 't')
// let c = new Column<number>('c')
// let cn = new PostgreSqlConnection()
// cn.insertInto(t)
//     .set(c).value(10)
//     .set(c).value(12)
//     .onConflictOnConstraint('f').doNothing().returningAll().execute()


let query5 = cn.selectFrom(t).where(t.c.equals(10)).and(t.bool).select({
    d: t.d,
    od: t.od,
    e: t.e,
    bool: cn.true().equals(t.bool.equals(t.bool)),
    isBigFactorial: cn.isBigFactorial(t.c, 100),
    customIsNull: cn.customIsNull(cn.true()),
    now: cn.now(),
    customBool: t.customBool,
    optCustomBool: t.optCustomBool
}).orderByFromString('d, od desc, e asc').limit(5).offset(4)

//let r5 = query5.executeSelectOne()
console.log(query5.query(), query5.params())

let query6 = cn.selectDistinctFrom(t).where(t.c.is(10)).and(t.od.isNot('d')).and(t.customBool.equals(t.optCustomBool)).select({
    d: t.d,
    od: t.od
})

//let r6 = query6.executeSelectOne()
console.log(query6.query(), query6.params())

let q2 = q.as('a')
let query7 = cn.selectFrom(t).from(q2).where(t.c.equals(q2.f)).select({
    d: t.d,
    f: q2.f
})

//let r7 = query7.executeSelectOne()
console.log(query7.query(), query7.params())

let query8 = cn.selectFromNoTable().select({
    date: cn.currentDate()
})

//let r8 = query8.executeSelectOne()
console.log(query8.query(), query8.params())

let query9 = cn.selectFrom(t).join(q).on(t.c.equals(q.f)).where(t.c.equals(10)).and(t.od.notEquals('d')).select({
    d: t.d,
    od: t.od,
    f: q.f
})

//let r9 = query9.executeSelectOne()
console.log(query9.query(), query9.params())


let query10 = cn.selectFrom(t)
    .innerJoin(q).dynamicOn().and(t.c.equals(q.f)).and(t.c.greaterOrEquals(12))
    .where(t.c.equals(10)).and(t.od.notEquals('d'))
    .select({
        d: t.d,
        od: t.od,
        f: q.f
    })

//let r10 = query10.executeSelectOne()
console.log(query10.query(), query10.params())

var ot = t.forUseInLeftJoinAs('jo')
let query11 = cn.selectFrom(q)
    .leftOuterJoin(ot).on(ot.c.equals(q.f))
    .innerJoin(q).on(ot.c.equals(q.f))
    .where(ot.c.equals(10)).and(ot.od.notEquals('d'))
    .select({
        d: ot.d,
        od: ot.od,
        f: q.f
    }).limit(10)

//let r11 = query11.executeSelectOne()
console.log(query11.query(), query11.params())

let subquery12 = cn.selectFrom(q).where(q.f.equals(1)).select({f: q.f})
let query12 = cn.selectDistinctFrom(t).where(t.c.equals(10)).and(cn.exists(subquery12)).select({
    d: t.d,
    od: t.od
})

//let r12 = query12.executeSelectOne()
console.log(query12.query(), query12.params())

let subquery13 = cn.subSelectUsing(t).from(q).where(q.f.equals(t.c)).select({f: q.f})
let query13 = cn.selectDistinctFrom(t).where(t.c.equals(10)).and(cn.notExists(subquery13)).select({
    d: t.d,
    od: t.od
})

//let r13 = query13.executeSelectOne()
console.log(query13.query(), query13.params())

let subquery14 = cn.selectFrom(q).where(q.f.equals(1)).selectOneColumn(q.f)
let query14 = cn.selectDistinctFrom(t).where(t.c.equals(10)).and(t.c.in(subquery14)).select({
    d: t.d,
    od: t.od
})

//let r14 = query14.executeSelectOne()
console.log(query14.query(), query14.params())

let subquery15 = cn.subSelectUsing(t).from(q).where(q.f.equals(t.c)).selectOneColumn(q.f)
let query15 = cn.selectDistinctFrom(t).where(t.c.equals(10)).and(t.c.notIn(subquery15)).select({
    d: t.d,
    od: t.od
})

//let r15 = query15.executeSelectOne()
console.log(query15.query(), query15.params())

cn.procedure1(16)
cn.function1(17).catch(_ => undefined) // ignore error

//cn.fragment`${t.c} <|> ${cn.const(7, 'int')}`.withType('boolean', 'required')
let query16 = cn.selectFrom(t).where(t.c.equals(9)).and(cn.fragmentWithType('boolean', 'required').sql`${t.c} <|> ${cn.const(7, 'int')}`).select({
    d: cn.fragmentWithType('int', 'required').sql`max2(${t.d})`,
    od: t.od
})

//let r16 = query16.executeSelectOne()
console.log(query16.query(), query16.params())

let query17 = cn.selectFrom(t).where(t.c.equals(10)).and(t.bool).select({
    cd: t.d,
    cod: t.od,
    ce: t.e,
    cbool: cn.true().equals(t.bool.equals(t.bool))
}).groupBy('cd', 'cod').groupBy('ce').orderByFromString('cd, cod desc, ce asc').limit(5).offset(4)

//let r5 = query5.executeSelectOne()
console.log(query17.query(), query17.params())

let query18 = cn.selectFrom(t).where(t.c.equals(10)).and(t.bool).select({
    cd: t.d,
    cod: t.od,
    ce: t.e,
    cbool: cn.true().equals(t.bool.equals(t.bool))
}).groupBy(t.d, t.od).groupBy(t.e).orderByFromString('cd, cod desc, ce asc').limit(5).offset(4)

//let r5 = query5.executeSelectOne()
console.log(query18.query(), query18.params())

let query19 = cn.selectFrom(t).where(t.c.equals(10)).and(t.bool).select({
    cd: t.d,
    cod: t.od,
    ce: t.e,
    cbool: cn.true().equals(t.bool.equals(t.bool))
}).groupBy('cd', 'cod').groupBy('ce').having(t.d.equals('a')).and(t.od.isNotNull()).orderByFromString('cd, cod desc, ce asc').limit(5).offset(4)

//let r5 = query5.executeSelectOne()
console.log(query19.query(), query19.params())

let query20 = cn.selectFrom(t).where(t.c.equals(10)).and(t.bool).select({
    cd: t.d,
    cod: t.od,
    ce: t.e,
    cbool: cn.true().equals(t.bool.equals(t.bool))
}).groupBy(t.d, t.od).groupBy(t.e).dynamicHaving().and(t.d.equals('a')).or(t.od.isNotNull()).orderByFromString('cd, cod desc, ce asc').limit(5).offset(4)

//let r5 = query5.executeSelectOne()
console.log(query20.query(), query20.params())

let query21 = cn.selectFrom(t).where(t.c.equals(10)).and(t.bool).groupBy(t.d, t.od).groupBy(t.e).select({
    cd: t.d,
    cod: t.od,
    ce: t.e,
    cbool: cn.true().equals(t.bool.equals(t.bool))
}).orderByFromString('cd, cod desc, ce asc').limit(5).offset(4)

//let r5 = query5.executeSelectOne()
console.log(query21.query(), query21.params())

let query22 = cn.selectFrom(t).where(t.c.equals(10)).and(t.bool).groupBy(t.d, t.od).groupBy(t.e).dynamicHaving().and(t.d.equals('a')).or(t.od.isNotNull()).select({
    cd: t.d,
    cod: t.od,
    ce: t.e,
    cbool: cn.true().equals(t.bool.equals(t.bool))
}).orderByFromString('cd, cod desc, ce asc').limit(5).offset(4)

//let r5 = query5.executeSelectOne()
console.log(query22.query(), query22.params())

let query23 = cn.selectFrom(t).where(t.c.equals(10)).and(t.bool).groupBy(t.od, t.e).select({
    count: cn.stringConcat(t.d),
    cod: t.od,
    ce: t.e
}).orderByFromString('count, cod desc, ce asc').limit(5).offset(4)

//let r5 = query5.executeSelectOne()
console.log(query23.query(), query23.params())

cn.rollback()

const pushers = new (class extends Table<MyConection, 'pushers'> {
    id = this.primaryKey('id', 'string');
    meta = this.column<any>('meta', 'custom', 'json');
    tags = this.column<string[]>('tags', 'custom', 'json');
    constructor() {
        super('pushers');
    }
})();

let query24 = cn.insertInto(pushers).values({id:'uuid', meta: { whatever: 123 }, tags:['a', 'b', 'c']})
console.log(query24.query(), query24.params())

/********************************************************************************************** */

class AConection extends TypeSafeMySqlConnection<'adb'> { }

const tPerson = new class TPerson extends Table<AConection, 'TPerson'> {
    public id = this.autogeneratedPrimaryKey("id", "int");
    public email = this.column("email", "string");
    public name = this.column("name", "string");
    public tfn = this.column("tfn", "string");
    public countryId = this.column("countryId", "int"); // FK

    constructor() {
        super("person"); // table name in the database
    }
}()

const tUser = new class TUser extends Table<AConection, 'TUser'> {
    public id = this.autogeneratedPrimaryKey("id", "int");
    public personId = this.column("personId", "int");
    public passwdId = this.column("passwdId", "int");
    public dateRegister = this.column("dateRegister", "localDateTime");
    public acceptGdpr = this.column("acceptGdpr", "boolean");
    public enabled = this.column("enabled", "boolean");
    public signInType = this.column("signInType", "int");

    constructor() {
        super("user"); // table name in the database
    }
}()

const tPasswd = new class TPasswd extends Table<AConection, 'TPasswd'> {
    public id = this.autogeneratedPrimaryKey("id", "int");
    public passwd = this.column("passwd", "string");
    public dateInit = this.column("dateInit", "localDateTime");
    public dateEnd = this.column("dateEnd", "localDateTime");

    constructor() {
        super("passwd"); // table name in the database
    }
}()

const cnn = new AConection(new ConsoleLogQueryRunner(new NoopQueryRunner()))

const username = 'un'

const passwords = tPasswd.as("passwords")
const persons = tPerson.as("persons")

const queryHandle = cnn
  .selectFrom(tUser)
  .join(persons).on(tUser.personId.equals(persons.id))
  .join(passwords).on(tUser.passwdId.equals(passwords.id))
  .where(persons.name.equals(username))
  .and(tUser.acceptGdpr)
  .and(tUser.enabled)
  .selectOneColumn(passwords.passwd)

const querya = queryHandle.query()
const parmsa = queryHandle.params()

console.log(querya, parmsa);

/********************************************************************************************** */

class DBConection extends PostgreSqlConnection<'DBConnection'> { 
    // insesitiveCollation = 'acs'

    bitwiseShiftLeft = this.buildFragmentWithArgs(
        this.arg('int', 'required'),
        this.arg('int', 'required')
    ).as((left, right) => {
        // The fragment here is: ${left} << ${right}
        // Could be another fragment like a function call: myFunction(${left}, ${right})
        return this.fragmentWithType('int', 'required').sql`${left} << ${right}`
    })

    valuePlusOneEqualsIfValue = this.buildFragmentWithArgsIfValue(
        this.arg('int', 'required'),
        this.valueArg('int', 'optional')
    ).as((left, right) => {
        // The fragment here is: ${left} + 1 = ${right}
        // Could be another fragment like a function call: myFunction(${left}, ${right})
        return this.fragmentWithType('boolean', 'required').sql`${left} + 1 = ${right}`
    })

    forSystemTimeBetween = this.createTableOrViewCustomization<Date, Date>((table, alias, fromDate, toDate) => {
        const from = this.const(fromDate, 'localDateTime')
        const to = this.const(toDate, 'localDateTime')
        return this.rawFragment`${table} for system_time between ${from} and ${to} ${alias}`
    })
}

const tCompany = new class TCompany extends Table<DBConection, 'TCompany'> {
    id = this.autogeneratedPrimaryKey('id', 'int')
    name = this.column('name', 'string')
    parentId = this.optionalColumn('parent_id', 'int')
    constructor() {
        super('company'); // table name in the database
    }
}()

const tCustomer = new class TCustomer extends Table<DBConection, 'TCustomer'> {
    id = this.autogeneratedPrimaryKey('id', 'int')
    firstName = this.column('first_name', 'string')
    lastName = this.column('last_name', 'string')
    birthday = this.optionalColumn('birthday', 'localDate')
    companyId = this.column('company_id', 'int')
    constructor() {
        super('customer'); // table name in the database
    }
}()

const vCustomerAndCompany = new class VCustomerAndCompany extends View<DBConection, 'VCustomerAndCompany'> {
    companyId = this.column('company_id', 'int')
    companyName = this.column('company_name', 'string')
    customerId = this.column('customer_id', 'int')
    customerFirstName = this.column('customer_first_name', 'string')
    customerLastName = this.column('customer_last_name', 'string')
    customerBirthday = this.optionalColumn('customer_birthday', 'localDate')
    constructor() {
        super('customer_company')
    }
}()

const results: any[] = []
const postResults: any[] = []
const mockQueryRunner = new MockQueryRunner(
    (_type, _query, _params, index) => {
        return results[index]
    }
)

const connection = new DBConection(/*postgre pg connection*/ new ConsoleLogQueryRunner(mockQueryRunner))

results.push({
    id: 1,
    firstName: 'First Name',
    lastName: 'Last Name'
})

const customerId = 10

const customerWithId = connection.selectFrom(tCustomer)
    .where(tCustomer.id.equals(customerId))
    .select({
        id: tCustomer.id,
        firstName: tCustomer.firstName,
        lastName: tCustomer.lastName,
        birthday: tCustomer.birthday
    })
    .executeSelectOne()

// Query: select id as id, first_name as firstName, last_name as lastName, birthday as birthday from customer where id = $1
// Params: [ 10 ]

results.push([])

const firstNameContains = 'ohn'
const lastNameContains = null
const birthdayIs = null
const searchOrderBy = 'name insensitive, birthday asc nulls last'

const searchedCustomers = connection.selectFrom(tCustomer)
    .where(
                tCustomer.firstName.containsIfValue(firstNameContains)
            .or(tCustomer.lastName.containsIfValue(lastNameContains))
        ).and(
            tCustomer.birthday.equalsIfValue(birthdayIs)
        )
    .select({
        id: tCustomer.id,
        name: tCustomer.firstName.concat(' ').concat(tCustomer.lastName),
        birthday: tCustomer.birthday
    })
    .orderByFromString(searchOrderBy)
    .executeSelectMany()

// Query: select id as id, first_name || $1 || last_name as name, birthday as birthday from customer where first_name like ('%' || $2 || '%') order by lower(name), birthday asc nulls last
// Params: [ ' ', 'ohn' ]

results.push([])

let searchedCustomersWhere = connection.dynamicBooleanExpressionUsing(tCustomer)
if (firstNameContains) {
    searchedCustomersWhere = searchedCustomersWhere.and(tCustomer.firstName.contains(firstNameContains))
}
if (lastNameContains) {
    searchedCustomersWhere = searchedCustomersWhere.or(tCustomer.lastName.contains(lastNameContains))
}
if (birthdayIs) {
    searchedCustomersWhere = searchedCustomersWhere.and(tCustomer.birthday.equals(birthdayIs))
}

const searchedCustomers2 = connection.selectFrom(tCustomer)
    .where(searchedCustomersWhere)
    .select({
        id: tCustomer.id,
        name: tCustomer.firstName.concat(' ').concat(tCustomer.lastName),
        birthday: tCustomer.birthday
    })
    .orderByFromString(searchOrderBy)
    .executeSelectMany()

// Query: select id as id, first_name || $1 || last_name as name, birthday as birthday from customer where first_name like ('%' || $2 || '%') order by lower(name), birthday asc nulls last
// Params: [ ' ', 'ohn' ]

results.push([])

const hideId = false

let searchedCustomersWhere3
if (firstNameContains) {
    searchedCustomersWhere3 = tCustomer.firstName.contains(firstNameContains)
} else {
    searchedCustomersWhere3 = connection.noValueBoolean()
}
if (lastNameContains) {
    searchedCustomersWhere3 = mergeType(searchedCustomersWhere3).or(tCustomer.lastName.contains(lastNameContains))
}
if (birthdayIs) {
    searchedCustomersWhere3 = mergeType(searchedCustomersWhere3).and(tCustomer.birthday.equals(birthdayIs))
}
searchedCustomersWhere3 = mergeType(searchedCustomersWhere3)

let idColumn
if (hideId) {
    idColumn = connection.optionalConst(null, 'int')
} else {
    idColumn = tCustomer.id
}
idColumn = mergeType(idColumn)

const searchedCustomers3 = connection.selectFrom(tCustomer)
    .where(searchedCustomersWhere3)
    .select({
        id: idColumn,
        name: tCustomer.firstName.concat(' ').concat(tCustomer.lastName),
        birthday: tCustomer.birthday
    })
    .orderByFromString(searchOrderBy)
    .executeSelectMany()

// Query: select id as id, first_name || $1 || last_name as name, birthday as birthday from customer where first_name like ('%' || $2 || '%') order by lower(name), birthday asc nulls last
// Params: [ ' ', 'ohn' ]


results.push([])

const firstName = 'John'
const lastName = null

const company = tCompany.as('comp')
const customersWithCompanyName = connection.selectFrom(tCustomer)
    .innerJoin(company).on(tCustomer.companyId.equals(company.id))
    .where(tCustomer.firstName.startsWithInsensitive(firstName))
        .and(tCustomer.lastName.startsWithInsensitiveIfValue(lastName))
    .select({
        id: tCustomer.id,
        firstName: tCustomer.firstName,
        lastName: tCustomer.lastName,
        birthday: tCustomer.birthday,
        companyName: company.name
    })
    .orderBy('firstName', 'insensitive')
    .orderBy('lastName', 'asc insensitive')
    .executeSelectMany()

// Query: select customer.id as id, customer.first_name as firstName, customer.last_name as lastName, customer.birthday as birthday, comp.name as companyName from customer inner join company as comp on customer.company_id = comp.id where customer.first_name ilike ($1 || '%') order by lower(firstName), lower(lastName) asc
// Params: [ 'John' ]

results.push([])

const orderBy = 'customerFirstName asc nulls first, customerLastName'
const customerWithSelectedCompanies = connection.selectFrom(tCustomer)
    .where(tCustomer.companyId.in(
        connection.selectFrom(tCompany)
            .where(tCompany.name.contains('Cia.'))
            .selectOneColumn(tCompany.id)
    )).select({
        customerId: tCustomer.id,
        customerFirstName: tCustomer.firstName,
        customerLastName: tCustomer.lastName
    }).orderByFromString(orderBy)
    .executeSelectMany()

// Query: select id as customerId, first_name as customerFirstName, last_name as customerLastName from customer where company_id in (select id as result from company where name like ('%' || $1 || '%')) order by customerFirstName asc nulls first, customerLastName
// Params: [ 'Cia.' ]

results.push([])

const customerCountPerCompany = connection.selectFrom(tCompany)
    .innerJoin(tCustomer).on(tCustomer.companyId.equals(tCompany.id))
    .select({
        companyId: tCompany.id,
        companyName: tCompany.name,
        customerCount: connection.count(tCustomer.id)
    }).groupBy('companyId', 'companyName')
    .executeSelectMany()

// Query: select company.id as companyId, company.name as companyName, count(customer.id) as customerCount from company inner join customer on customer.company_id = company.id group by company.id, company.name
// Params: []

results.push([])

const customerCountPerCompany2 = connection.selectFrom(tCompany)
    .innerJoin(tCustomer).on(tCustomer.companyId.equals(tCompany.id))
    .groupBy(tCompany.id, tCompany.name)
    .select({
        companyId: tCompany.id,
        companyName: tCompany.name,
        customerCount: connection.count(tCustomer.id)
    })
    .executeSelectMany()

// Query: select company.id as companyId, company.name as companyName, count(customer.id) as customerCount from company inner join customer on customer.company_id = company.id group by company.id, company.name
// Params: []

results.push([])
postResults.push(0)

const customerName = 'Smi'
const customerPageWithName = connection.selectFrom(tCustomer)
    .where(
        tCustomer.firstName.startsWithInsensitive(customerName)
    ).or(
        tCustomer.lastName.startsWithInsensitive(customerName)
    ).select({
        id: tCustomer.id,
        firstName: tCustomer.firstName,
        lastName: tCustomer.lastName
    })
    .orderBy('firstName')
    .orderBy('lastName')
    .limit(10)
    .offset(20)
    .executeSelectPage()

// Query: select id as id, first_name as firstName, last_name as lastName from customer where first_name ilike ($1 || '%') or last_name ilike ($2 || '%') order by firstName, lastName limit $3 offset $4
// Params: [ 'Smi', 'Smi', 10, 20 ]

// Query: select count(*) from customer where first_name ilike ($1 || '%') or last_name ilike ($2 || '%')
// Params: [ 'Smi', 'Smi' ]

results.push(null)

const id = 10
const customersUsingCustomFragment = connection.selectFrom(tCustomer)
    .where(connection.fragmentWithType('boolean', 'required').sql`!!${tCustomer.id} = !!${connection.const(id, 'int')}`)
    .select({
        idAsString: connection.fragmentWithType('string', 'required').sql`${tCustomer.id}::varchar`,
        name: tCustomer.firstName.concat(' ').concat(tCustomer.lastName)
    })
    .executeSelectNoneOrOne()

// Query: select id::varchar as idAsString, first_name || $1 || last_name as name from customer where !!id = !!$2
// Params: [ ' ', 10 ]

results.push([])

const bitwiseMovements = 1
const multiplier = 2
const companiesUsingCustomFunctionFragment = connection.selectFrom(tCompany)
    .where(tCompany.id.multiply(multiplier).equals(connection.bitwiseShiftLeft(tCompany.id, bitwiseMovements)))
    .select({
        id: tCompany.id,
        name: tCompany.name,
        idMultiplyBy2: connection.bitwiseShiftLeft(tCompany.id, bitwiseMovements)
    })
    .executeSelectMany()

// Query: select id as id, name as name, id << $1 as idMultiplyBy2 from company where (id * $2) = (id << $3)
// Params: [ 1, 2, 1 ]

results.push([])

const noValue = null
const withValue = 2
const companiesUsingCustomFunctionFragmentIfValue = connection.selectFrom(tCompany)
    .where(connection.valuePlusOneEqualsIfValue(tCompany.id, noValue))
        .or(connection.valuePlusOneEqualsIfValue(tCompany.id, withValue))
    .select({
        id: tCompany.id,
        name: tCompany.name,
    })
    .executeSelectMany()

// Query: select id as id, name as name from company where id + 1 = $1
// Params: [ 2 ]

results.push(1)

const insertCustomer = connection.insertInto(tCustomer).set({
        firstName: 'John',
        lastName: 'Smith',
        companyId: 1
    }).setIfNotSet({
        birthday: new Date()
    }).returningLastInsertedId()
    .executeInsert()

// Query: insert into customer (first_name, last_name, company_id, birthday) values ($1, $2, $3, $4) returning id
// Params: [ 'John', 'Smith', 1, 2019-08-16T15:02:32.849Z ]

results.push([2, 3])

const valuesToInsert = [
    {
        firstName: 'John',
        lastName: 'Smith',
        companyId: 1
    },
    {
        firstName: 'Other',
        lastName: 'Person',
        companyId: 1
    }
]

const insertMultipleCustomers = connection.insertInto(tCustomer)
    .values(valuesToInsert)
    .returningLastInsertedId()
    .executeInsert();

// Query: insert into customer (first_name, last_name, company_id) values ($1, $2, $3), ($4, $5, $6) returning id
// Params: [ 'John', 'Smith', 1, 'Other', 'Person', 1 ]

results.push(1)

const insertCustomersFromSelect = connection.insertInto(tCustomer)
    .from(
        connection.selectFrom(tCustomer)
        .where(
            tCustomer.companyId.equals(1)
        )
        .select({
            firstName: tCustomer.firstName,
            lastName: tCustomer.lastName,
            companyId: tCustomer.companyId
        })
    )
    .executeInsert();

// Query: insert into customer (first_name, last_name, company_id) select first_name as firstName, last_name as lastName, company_id as companyId from customer where company_id = $1 
// Params: [ 1 ]

results.push(1)

const updateCustomer = connection.update(tCustomer).set({
        firstName: 'John',
        lastName: 'Smith',
        birthday: new Date()
    }).ignoreIfSet('birthday')
    .where(tCustomer.id.equals(10))
    .executeUpdate()

// Query: update customer set first_name = $1, last_name = $2 where id = $3
// Params: [ 'John', 'Smith', 10 ]

results.push(1)

const deleteCustomer = connection.deleteFrom(tCustomer)
    .where(tCustomer.id.equals(10))
    .executeDelete()

// Query: delete from customer where id = $1
// Params: [ 10 ]

results.push([])

const customerCountPerCompanyWith = connection.selectFrom(tCompany)
    .innerJoin(tCustomer).on(tCustomer.companyId.equals(tCompany.id))
    .select({
        companyId: tCompany.id,
        companyName: tCompany.name,
        customerCount: connection.count(tCustomer.id)
    }).groupBy('companyId', 'companyName')
    .forUseInQueryAs('customerCountPerCompany')

const customerCountPerAcmeCompanies = connection.selectFrom(customerCountPerCompanyWith)
    .where(customerCountPerCompanyWith.companyName.containsInsensitive('ACME'))
    .select({
        acmeCompanyId: customerCountPerCompanyWith.companyId,
        acmeCompanyName: customerCountPerCompanyWith.companyName,
        acmeCustomerCount: customerCountPerCompanyWith.customerCount
    })
    .executeSelectMany()

// Query: with customerCountPerCompany as (select company.id as companyId, company.name as companyName, count(customer.id) as customerCount from company inner join customer on customer.company_id = company.id group by company.id, company.name) select companyId as "acmeCompanyId", companyName as "acmeCompanyName", customerCount as "acmeCustomerCount" from customerCountPerCompany where companyName ilike ('%' || $1 || '%')
// Params: [ 'ACME' ]

const tCustomCompany = new class TCustomCompany extends Table<DBConection, 'TCustomCompany'> {
    id = this.autogeneratedPrimaryKey('id', 'int');
    name = this.column('name', 'string');
    isBig = this.column('is_big', 'boolean', new CustomBooleanTypeAdapter('Y', 'N'));
    constructor() {
        super('custom_company'); // table name in the database
    }
}()

results.push(1)

const insertCustomCompany = connection.insertInto(tCustomCompany).set({
        name: 'My Big Company',
        isBig: true
    }).returningLastInsertedId()
    .executeInsert()

// Query: insert into custom_company (name, is_big) values ($1, case when $2 then 'Y' else 'N' end) returning id
// Params: [ 'My Big Company', true ]

results.push([])

const selectAllBigCompanies = connection.selectFrom(tCustomCompany)
    .where(tCustomCompany.isBig)
    .select({
        id: tCustomCompany.id,
        name: tCustomCompany.name,
        isBig: tCustomCompany.isBig
    }).executeSelectMany()

// Query: select id as id, name as name, (is_big = 'Y') as isBig from custom_company where (is_big = 'Y')
// Params: []

results.push([])

type FilterType = DynamicCondition<{
    id: 'int',
    firstName: 'string',
    lastName: 'string',
    birthday: 'localDate',
    companyName: 'string'
}>

const filter: FilterType = {
    or: [
        { firstName: { startsWithInsensitive: 'John' } },
        { lastName: { startsWithInsensitiveIfValue: 'Smi', endsWith: 'th' } }
    ],
    companyName: {equals: 'ACME'}
}

const selectFields = {
    id: tCustomer.id,
    firstName: tCustomer.firstName,
    lastName: tCustomer.lastName,
    birthday: tCustomer.birthday,
    companyName: tCompany.name
}

const dynamicWhere = connection.dynamicConditionFor(selectFields).withValues(filter)

const customersWithDynamicCondition = connection.selectFrom(tCustomer)
    .innerJoin(tCompany).on(tCustomer.companyId.equals(tCompany.id))
    .where(dynamicWhere)
    .select(selectFields)
    .orderBy('firstName', 'insensitive')
    .orderBy('lastName', 'asc insensitive')
    .executeSelectMany()

// Query: select customer.id as id, customer.first_name as "firstName", customer.last_name as "lastName", customer.birthday as birthday, company.name as "companyName" from customer inner join company on customer.company_id = company.id where (customer.first_name ilike ($1 || '%') or (customer.last_name ilike ($2 || '%') and customer.last_name like ('%' || $3))) and company.name = $4 order by lower("firstName"), lower("lastName") asc
// Params: [ 'John', 'Smi', 'th', 'ACME' ]

results.push([])

const allDataWithName = connection.selectFrom(tCustomer)
    .select({
        id: tCustomer.id,
        name: tCustomer.firstName.concat(' ').concat(tCustomer.lastName),
        type: connection.const<'customer' | 'company'>('customer', 'enum', 'customerOrCompany')
    }).unionAll(
        connection.selectFrom(tCompany)
        .select({
            id: tCompany.id,
            name: tCompany.name,
            type: connection.const<'customer' | 'company'>('company', 'enum', 'customerOrCompany')
        })
    ).executeSelectMany()

// Query: select id as id, first_name || $1 || last_name as name, $2 as type from customer union all select id as id, name as name, $3 as type from company
// Params: [ ' ', 'customer', 'company' ]

results.push([{
    id: 10,
    name: 'ACME Inc.'
}, {
    id: 11,
    name: 'ACME Corp.'
}])
postResults.push([{
    id: 12,
    firstName: 'John',
    lastName: 'Smith',
    birthday: new Date('1990/1/14'),
    companyId: 10
}, {
    id: 13,
    firstName: 'Jorge',
    lastName: 'Justo',
    birthday: new Date('1991/2/16'),
    companyId: 10

}, {
    id: 14,
    firstName: 'Maria',
    lastName: 'Rodriguez',
    birthday: new Date('1992/3/18'),
    companyId: 11

}])

const companiesWithCustomers = connection.selectFrom(tCompany)
        .select({
            id: tCompany.id,
            name: tCompany.name
        }).where(
            tCompany.name.containsInsensitive('ACME')
        ).composeDeletingInternalProperty({
            externalProperty: 'id',
            internalProperty: 'companyId',
            propertyName: 'customers'
        }).withMany((ids) => {
            return connection.selectFrom(tCustomer)
                .select({
                    id: tCustomer.id,
                    firstName: tCustomer.firstName,
                    lastName: tCustomer.lastName,
                    birthday: tCustomer.birthday,
                    companyId: tCustomer.companyId
                }).where(
                    tCustomer.companyId.in(ids)
                ).executeSelectMany()
        }).executeSelectMany()

// ---------------

results.push({
    id: 12,
    firstName: 'John',
    lastName: 'Smith',
    birthday: new Date('1990/1/14'),
    companyId: 10
})
postResults.push([{
    id: 10,
    name: 'ACME Inc.'
}])

const customerWithCompany = connection.selectFrom(tCustomer)
        .select({
            id: tCustomer.id,
            firstName: tCustomer.firstName,
            lastName: tCustomer.lastName,
            birthday: tCustomer.birthday,
            companyId: tCustomer.companyId
        }).where(
            tCustomer.id .equals(12)
        ).composeDeletingExternalProperty({
            externalProperty: 'companyId',
            internalProperty: 'id',
            propertyName: 'company'
        }).withOne((ids) => {
            return connection.selectFrom(tCompany)
                .select({
                    id: tCompany.id,
                    name: tCompany.name
                }).where(
                    tCompany.id.in(ids)
                ).executeSelectMany()
        }).executeSelectOne()

// ---------------

results.push({
    id: 12,
    firstName: 'John',
    lastName: 'Smith',
    birthday: new Date('1990/1/14'),
    companyId: 10,
    companyName: 'ACME Inc.'
})

const customerWithCompanyInOneQuery = connection.selectFrom(tCustomer)
        .innerJoin(tCompany).on(tCompany.id.equals(tCustomer.companyId))
        .select({
            id: tCustomer.id,
            firstName: tCustomer.firstName,
            lastName: tCustomer.lastName,
            birthday: tCustomer.birthday,
            companyId: tCompany.id,
            companyName: tCompany.name
        }).where(
            tCustomer.id .equals(12)
        ).split('company', {
            id: 'companyId',
            name: 'companyName'
        }).executeSelectOne()

// ---------------

results.push({
    id: 12,
    firstName: 'John',
    lastName: 'Smith',
    birthday: new Date('1990/1/14'),
    'company.id': 10,
    'company.name': 'ACME Inc.'
})

type QueryFilterType = DynamicCondition<{
    id: 'int',
    firstName: 'string',
    lastName: 'string',
    birthday: 'localDate',
    'company.id': 'int',
    'company.name': 'string'
}>

const queryFilter: QueryFilterType = {
    'company.name': {equals: 'ACME'},
    or: [
        { firstName: { containsInsensitive: 'John' } },
        { lastName: { containsInsensitive: 'Smi' } }
    ]
}

const queryOrderBy = 'company.name asc insensitive, birthday desc'

const querySelectFields = {
    id: tCustomer.id,
    firstName: tCustomer.firstName,
    lastName: tCustomer.lastName,
    birthday: tCustomer.birthday,
    'company.id': tCompany.id,
    'company.name': tCompany.name
}

const queryDynamicWhere = connection.dynamicConditionFor(querySelectFields).withValues(queryFilter)

const customerWithCompanyObject = connection.selectFrom(tCustomer)
        .innerJoin(tCompany).on(tCompany.id.equals(tCustomer.companyId))
        .select(querySelectFields)
        .where(queryDynamicWhere)
        .orderByFromString(queryOrderBy)
        .split('company', {
            id: 'company.id',
            name: 'company.name'
        }).executeSelectOne()

// Query: select customer.id as id, customer.first_name as "firstName", customer.last_name as "lastName", customer.birthday as birthday, company.id as "company.id", company.name as "company.name" from customer inner join company on company.id = customer.company_id where company.name = $1 and (customer.first_name ilike ('%' || $2 || '%') or customer.last_name ilike ('%' || $3 || '%')) order by lower("company.name") asc, birthday desc
// Params: [ 'John', 'Smi', 'ACME' ]

results.push([])

const recursiveParentCompany = connection.selectFrom(tCompany)
    .where(tCompany.id.equals(10))
    .select({
        id: tCompany.id,
        name: tCompany.name,
        parentId: tCompany.parentId
    }).recursiveUnion((child) => {
        return connection.selectFrom(tCompany)
        .join(child).on(child.parentId.equals(tCompany.id))
        .select({
            id: tCompany.id,
            name: tCompany.name,
            parentId: tCompany.parentId
        })
    }).executeSelectMany()

// Query: with recursive recursive_select_1 as (select id as id, name as name, parent_id as parentId from company where id = $1 union select company.id as id, company.name as name, company.parent_id as parentId from company join recursive_select_1 on recursive_select_1.parentId = company.id) select id as id, name as name, parentId as "parentId" from recursive_select_1
// Params: [ 10 ]

results.push([])

const recursiveOnParentCompany = connection.selectFrom(tCompany)
    .where(tCompany.id.equals(10))
    .select({
        id: tCompany.id,
        name: tCompany.name,
        parentId: tCompany.parentId
    }).recursiveUnionOn((child) => {
        return child.parentId.equals(tCompany.id)
    }).executeSelectMany()

// Query: with recursive recursive_select_1 as (select id as id, name as name, parent_id as parentId from company where id = $1 union select company.id as id, company.name as name, company.parent_id as parentId from company join recursive_select_1 on recursive_select_1.parentId = company.id) select id as id, name as name, parentId as "parentId" from recursive_select_1
// Params: [ 10 ]

results.push([])

const recursiveChildrenCompany = connection.selectFrom(tCompany)
    .where(tCompany.id.equals(10))
    .select({
        id: tCompany.id,
        name: tCompany.name,
        parentId: tCompany.parentId
    }).recursiveUnionAll((parent) => {
        return connection.selectFrom(tCompany)
        .join(parent).on(parent.id.equals(tCompany.parentId))
        .select({
            id: tCompany.id,
            name: tCompany.name,
            parentId: tCompany.parentId
        })
    }).executeSelectMany()

// Query: with recursive recursive_select_1 as (select id as id, name as name, parent_id as parentId from company where id = $1 union all select company.id as id, company.name as name, company.parent_id as parentId from company join recursive_select_1 on recursive_select_1.id = company.parent_id) select id as id, name as name, parentId as "parentId" from recursive_select_1
// Params: [ 10 ]

results.push([])

const recursiveOnChildrenCompany = connection.selectFrom(tCompany)
    .where(tCompany.id.equals(10))
    .select({
        id: tCompany.id,
        name: tCompany.name,
        parentId: tCompany.parentId
    }).recursiveUnionAllOn((parent) => {
        return parent.id.equals(tCompany.parentId)
    }).executeSelectMany()

// Query: with recursive recursive_select_1 as (select id as id, name as name, parent_id as parentId from company where id = $1 union all select company.id as id, company.name as name, company.parent_id as parentId from company join recursive_select_1 on recursive_select_1.id = company.parent_id) select id as id, name as name, parentId as "parentId" from recursive_select_1
// Params: [ 10 ]

results.push([{
    id: 18,
    name: 'name'
}, {
    id: 19,
    name: 'name2',
    parentId: 18,
    parentName: 'name'
}])

const parent = tCompany.forUseInLeftJoinAs('parent')

const leftJoinCompany = connection.selectFrom(tCompany)
    .leftJoin(parent).on(tCompany.parentId.equals(parent.id))
    .select({
        id: tCompany.id,
        name: tCompany.name,
        parentId: parent.id,
        parentName: parent.name
    }).guidedSplitOptional('parent', {
        id: 'parentId!',
        name: 'parentName!'
    }).executeSelectMany()

// Query: select company.id as id, company.name as name, parent.id as parentId, parent.name as parentName from company left join company as parent on company.parent_id = parent.id
// Params: [ ]

results.push({
    id: 1,
    firstName: 'First Name',
    lastName: 'Last Name'
})

const availableFields = {
    id: tCustomer.id,
    firstName: tCustomer.firstName,
    lastName: tCustomer.lastName,
    birthday: tCustomer.birthday
}

const fieldsToPick = {
    firstName: true,
    lastName: true
}

// include allways id field as required
const pickedFields = dynamicPick(availableFields, fieldsToPick, ['id'])

const customerWithIdPeaking = connection.selectFrom(tCustomer)
    .select(pickedFields)
    .executeSelectOne()

// Query: select id as id, first_name as "firstName", last_name as "lastName" from customer
// Params: [ ]

results.push([])

const availableFields2 = {
    id: tCustomer.id,
    firstName: tCustomer.firstName,
    lastName: tCustomer.lastName,
    birthday: tCustomer.birthday,
    companyId: tCompany.id,
    companyName: tCompany.name
}

const fieldsToPick2 = {
    firstName: true,
    lastName: true
}

// include allways id field as required
const pickedFields2 = dynamicPick(availableFields2, fieldsToPick2, ['id'])

const customerWithOptionalCompany = connection.selectFrom(tCustomer)
    .optionalInnerJoin(tCompany).on(tCompany.id.equals(tCustomer.companyId))
    .select(pickedFields2)
    .where(tCustomer.id.equals(12))
    .executeSelectMany()

// Query: select customer.id as id, customer.first_name as "firstName", customer.last_name as "lastName" from customer where customer.id = $1
// Params: [ 12 ]

/*

const fieldsToPick2 = {
    firstName: true,
    lastName: true,
    companyName: true
}

// Query: select customer.id as id, customer.first_name as "firstName", customer.last_name as "lastName", company.name as "companyName" from customer inner join company on company.id = customer.company_id where customer.id = $1
// Params: [ 12 ]

*/

results.push([])

const customerIn2019 = connection.forSystemTimeBetween(tCustomer, 'customerIn2019', new Date('2019-01-01'), new Date('2020-01-01'))

const customerInSystemTime = connection.selectFrom(customerIn2019)
    .where(customerIn2019.id.equals(10))
    .select({
        id: customerIn2019.id,
        firstName: customerIn2019.firstName,
        lastName: customerIn2019.lastName,
        birthday: customerIn2019.birthday
    })
    .executeSelectMany()

// Query: select id as id, first_name as "firstName", last_name as "lastName", birthday as birthday from customer for system_time between $1 and $2  where id = $3
// Params: [ 2019-01-01T00:00:00.000Z, 2020-01-01T00:00:00.000Z, 10 ]

results.push({
    id: 1,
    firstName: 'First Name',
    lastName: 'Last Name'
})

const customizedSelect = connection.selectFrom(tCustomer)
    .where(tCustomer.id.equals(10))
    .select({
        id: tCustomer.id,
        firstName: tCustomer.firstName,
        lastName: tCustomer.lastName,
        birthday: tCustomer.birthday
    }).customizeQuery({
        afterSelectKeyword: connection.rawFragment`/*+ some hints */`,
        afterQuery: connection.rawFragment`for update`
    })
    .executeSelectOne()

// Query: select /*+ some hints */ id as id, first_name as "firstName", last_name as "lastName", birthday as birthday from customer where id = $1 for update
// Params: [ 10 ]

results.push(1)

const customizedUpdate = connection.update(tCustomer).set({
        firstName: 'John',
        lastName: 'Smith'
    }).where(tCustomer.id.equals(10))
    .customizeQuery({
        afterUpdateKeyword: connection.rawFragment`/*+ some hints */`,
        afterQuery: connection.rawFragment`keep plan`,
    })
    .executeUpdate()

// Query: update /*+ some hints */ customer set first_name = $1, last_name = $2 where id = $3 keep plan
// Params: [ 'John', 'Smith', 10 ]

results.push(1)

const customizedDelete = connection.deleteFrom(tCustomer)
    .where(tCustomer.id.equals(10))
    .customizeQuery({
        afterDeleteKeyword: connection.rawFragment`/*+ some hints */`,
        afterQuery: connection.rawFragment`keep plan`,
    })
    .executeDelete()

// Query: delete /*+ some hints */ from customer where id = $1 keep plan
// Params: [ 10 ]

results.push(1)

const customizedInsert = connection.insertInto(tCustomer).set({
        firstName: 'John',
        lastName: 'Smith',
        companyId: 1
    }).customizeQuery({
        afterInsertKeyword: connection.rawFragment`/*+ some hints */`,
        afterQuery: connection.rawFragment`log errors reject limit unlimited`
    }).executeInsert()

// Query: insert /*+ some hints */ into customer (first_name, last_name, company_id) values ($1, $2, $3) log errors reject limit unlimited
// Params: [ 'John', 'Smith', 1 ]

results.push({
    id: 9,
    firstName: 'First Name',
    lastName: 'Last Name',
    companyId: 7
})

const selectAll = connection.selectFrom(tCustomer)
    .select(extractColumnsFrom(tCustomer))
    .where(tCustomer.id.equals(9))
    .executeSelectOne()

// Query: select id as id, first_name as "firstName", last_name as "lastName", birthday as birthday, company_id as "companyId" from customer where id = $1
// Params: [ 9 ]

results.push({
    'customer.id': 12,
    'customer.firstName': 'John',
    'customer.lastName': 'Smith',
    'customer.birthday': new Date('1990/1/14'),
    'company.id': 10,
    'company.name': 'ACME Inc.'
})

const customerColumns = {
    id: tCustomer.id,
    firstName: tCustomer.firstName,
    lastName: tCustomer.lastName,
    birthday: tCustomer.birthday
}

const companyColumns = {
    id: tCompany.id,
    name: tCompany.name
}

const customerWithCompanyPrefixed = connection.selectFrom(tCustomer)
        .innerJoin(tCompany).on(tCompany.id.equals(tCustomer.companyId))
        .select({
            ...prefixDotted(customerColumns, 'customer'),
            ...prefixDotted(companyColumns, 'company')
        }).where(
            tCustomer.id.equals(12)
        )
        .split('customer', prefixMapForSplitDotted(customerColumns, 'customer'))
        .split('company', prefixMapForSplitDotted(companyColumns, 'company'))
        .executeSelectOne()

// Query: select customer.id as "customer.id", customer.first_name as "customer.firstName", customer.last_name as "customer.lastName", customer.birthday as "customer.birthday", company.id as "company.id", company.name as "company.name" from customer inner join company on company.id = customer.company_id where customer.id = $1
// Params: [ 12 ]

results.push({
    customerId: 12,
    customerFirstName: 'John',
    customerLastName: 'Smith',
    customerBirthday: new Date('1990/1/14'),
    companyId: 10,
    companyName: 'ACME Inc.'
})

const customerWithCompanyPrefixed2 = connection.selectFrom(tCustomer)
        .innerJoin(tCompany).on(tCompany.id.equals(tCustomer.companyId))
        .select({
            ...prefixCapitalized(customerColumns, 'customer'),
            ...prefixCapitalized(companyColumns, 'company')
        }).where(
            tCustomer.id.equals(12)
        )
        .split('customer', prefixMapForSplitCapitalized(customerColumns, 'customer'))
        .split('company', prefixMapForSplitCapitalized(companyColumns, 'company'))
        .executeSelectOne()

// Query: select customer.id as "customerId", customer.first_name as "customerFirstName", customer.last_name as "customerLastName", customer.birthday as "customerBirthday", company.id as "companyId", company.name as "companyName" from customer inner join company on company.id = customer.company_id where customer.id = $1
// Params: [ 12 ]

results.push([{
    id: 18,
    name: 'name'
}, {
    id: 19,
    name: 'name2',
    parentId: 18,
    parentName: 'name',
    parentParentId: null
}])

const parentCompany = tCompany.forUseInLeftJoinAs('parent')

const companyFields = {
    id: tCompany.id,
    name: tCompany.name
}

const parentCompanyFields = {
    id: parentCompany.id,
    name: parentCompany.name,
    parentId: parentCompany.parentId
}

const companyPrefixed = connection.selectFrom(tCompany)
    .leftJoin(parent).on(tCompany.parentId.equals(parent.id))
    .select({
        ...companyFields,
        ...prefixCapitalized(parentCompanyFields, 'parent')
    }).guidedSplitOptional('parent', prefixMapForGuidedSplitCapitalized(parentCompanyFields, tCompany, 'parent'))
    .executeSelectMany()

// Query: select company.id as id, company.name as name, parent.id as "parentId", parent.name as "parentName", parent.parent_id as "parentParentId" from company left join company as parent on company.parent_id = parent.id
// Params: [ ]

results.push([{
    id: 18,
    name: 'name'
}, {
    id: 19,
    name: 'name2',
    'parent.id': 18,
    'parent.name': 'name',
    'parent.parentId': 8
}])

const companyPrefixed2 = connection.selectFrom(tCompany)
    .leftJoin(parent).on(tCompany.parentId.equals(parent.id))
    .select({
        ...companyFields,
        ...prefixDotted(parentCompanyFields, 'parent')
    }).guidedSplitOptional('parent', prefixMapForGuidedSplitDotted(parentCompanyFields, tCompany, 'parent'))
    .executeSelectMany()

// Query: select company.id as id, company.name as name, parent.id as "parent.id", parent.name as "parent.name", parent.parent_id as "parent.parentId" from company left join company as parent on company.parent_id = parent.id
// Params: [ ]

results.push([{
    id: 18,
    name: 'name'
}, {
    id: 19,
    name: 'name2',
    parentId: 18,
    parentName: 'name'
}])

const parentFields = {
    parentId: parentCompany.id,
    parentName: parentCompany.name,
    parentParentId: parentCompany.parentId
}

const companyPrefixed3 = connection.selectFrom(tCompany)
    .leftJoin(parent).on(tCompany.parentId.equals(parent.id))
    .select({
        id: tCompany.id,
        name: tCompany.name,
        ...parentFields
    }).guidedSplitOptional('parent', mapForGuidedSplit(parentFields, {
        parentId: tCompany.id,
        parentName: tCompany.name,
        parentParentId: tCompany.parentId
    }))
    .executeSelectMany()

// Query: select company.id as id, company.name as name, parent.id as "parentId", parent.name as "parentName", parent.parent_id as "parentParentId" from company left join company as parent on company.parent_id = parent.id
// Params: [ ]


results.push([{
    id: 18,
    name: 'name'
}, {
    id: 19,
    name: 'name2',
    parentId: 18,
    parentName: 'name'
}, {
    id: 20,
    name: 'name3',
    parentId: 19,
    parentName: 'name2',
    parentParentId: 18,
    parentParentName: 'name',
    parentParentParentId: 17
}])

const parentParent = tCompany.forUseInLeftJoinAs('parentParent')

const companyMultiSplit = connection.selectFrom(tCompany)
    .leftJoin(parent).on(tCompany.parentId.equals(parent.id))
    .leftJoin(parentParent).on(parent.parentId.equals(parentParent.id))
    .select({
        id: tCompany.id,
        name: tCompany.name,
        parentId: parent.id,
        parentName: parent.name,
        parentParentId: parentParent.id,
        parentParentName: parentParent.name,
        parentParentParentId: parentParent.parentId,
    }).guidedSplitOptional('parentParent', {
        id: 'parentParentId!',
        name: 'parentParentName!',
        parentId: 'parentParentParentId'
    }).guidedSplitOptional('parent', {
        id: 'parentId!',
        name: 'parentName!',
        parent: 'parentParent'
    })
    .executeSelectMany()

// Query: select company.id as id, company.name as name, parent.id as "parentId", parent.name as "parentName", parentParent.id as "parentParentId", parentParent.name as "parentParentName", parentParent.parent_id as "parentParentParentId" from company left join company as parent on company.parent_id = parent.id left join company as parentParent on parent.parent_id = parentParent.id
// Params: [ ]

results.push([])

const acmeId = connection.selectFrom(tCompany)
    .where(tCompany.name.equals('ACME'))
    .selectOneColumn(tCompany.id)
    .forUseAsInlineQueryValue()

const acmeCustomers = connection.selectFrom(tCustomer)
    .where(tCustomer.companyId.equals(acmeId))
    .select({
        id: tCustomer.id,
        name: tCustomer.firstName.concat(' ').concat(tCustomer.lastName)
    })
    .executeSelectMany()

// Query:  select id as id, first_name || $1 || last_name as name from customer where company_id = (select id as result from company where name = $2)
// Params: [ ' ', 'ACME' ]

results.push({
    id: 10,
    name: 'ACME'
})

const deletedAcmeCompany = connection.deleteFrom(tCompany)
    .where(tCompany.name.equals('ACME'))
    .returning({
        id: tCompany.id,
        name: tCompany.name
    })
    .executeDeleteOne()

// Query:  delete from company where name = $1 returning id as id, name as name
// Params: [ 'ACME' ]

results.push('Ron')

const updatedSmithFirstName = connection.update(tCustomer)
    .set({
        firstName: 'Ron'
    })
    .where(tCustomer.id.equals(1))
    .returningOneColumn(tCustomer.firstName)
    .executeUpdateOne()

// Query:  update customer set first_name = $1 where id = $2 returning first_name as result
// Params: [ 'Ron', 1 ]

results.push({
    oldLastName: 'Shith', 
    newLastName: 'Thomson'
})

const oldCustomerValues = tCustomer.oldValues()
const updatedLastNames = connection.update(tCustomer)
    .set({
        lastName: 'Thomson'
    })
    .where(tCustomer.id.equals(2))
    .returning({
        oldLastName: oldCustomerValues.lastName,
        newLastName: tCustomer.lastName
    })
    .executeUpdateOne()

// Query:  update customer as _new_ set last_name = $1 from (select _old_.* from customer as _old_ where _old_.id = $2 for no key update of _old_) as _old_ where _new_.id = _old_.id returning _old_.last_name as "oldLastName", _new_.last_name as "newLastName"
// Params: [ 'Thomson', 2 ]

results.push({
    id: 1,
    firstName: 'John',
    lastName: 'Smith',
})

const insertReturningCustomerData = connection.insertInto(tCustomer).set({
        firstName: 'John',
        lastName: 'Smith',
        companyId: 1
    }).returning({
        id: tCustomer.id,
        firstName: tCustomer.firstName,
        lastName: tCustomer.lastName
    })
    .executeInsertOne()

// Query:  insert into customer (first_name, last_name, company_id) values ($1, $2, $3) returning id as id, first_name as "firstName", last_name as "lastName" 
// Params: [ 'John', 'Smith', 1 ]

results.push(1)

const addACMECompanyNameToLastName = connection.update(tCustomer)
    .from(tCompany)
    .set({
        lastName: tCustomer.lastName.concat(' - ').concat(tCompany.name)
    })
    .where(tCustomer.companyId.equals(tCompany.id))
    .and(tCompany.name.containsInsensitive('ACME'))
    .executeUpdate()

// Query:  update customer set last_name = customer.last_name || $1 || company.name from company where customer.company_id = company.id and company.name ilike ('%' || $2 || '%')
// Params: [ ' - ', 'ACME' ]

results.push(1)

const deleteACMECustomers = connection.deleteFrom(tCustomer)
    .using(tCompany)
    .where(tCustomer.companyId.equals(tCompany.id))
    .and(tCompany.name.containsInsensitive('ACME'))
    .executeDelete()

// Query:  delete from customer using company where customer.company_id = company.id and company.name ilike ('%' || $1 || '%')
// Params: [ 'ACME' ]

results.push(...postResults)

vCustomerAndCompany.as('foo')
searchedCustomers.finally(() => undefined)
searchedCustomers2.finally(() => undefined)
searchedCustomers3.finally(() => undefined)
customersWithCompanyName.finally(() => undefined)
customerWithSelectedCompanies.finally(() => undefined)
customerCountPerCompany.finally(() => undefined)
customerCountPerCompany2.finally(() => undefined)
insertCustomer.finally(() => undefined)
insertMultipleCustomers.finally(() => undefined)
insertCustomersFromSelect.finally(() => undefined)
updateCustomer.finally(() => undefined)
deleteCustomer.finally(() => undefined)
customersUsingCustomFragment.finally(() => undefined)
companiesUsingCustomFunctionFragment.finally(() => undefined)
companiesUsingCustomFunctionFragmentIfValue.finally(() => undefined)
customerPageWithName.finally(() => undefined)
customerWithId.finally(() => undefined)
customerCountPerAcmeCompanies.finally(() => undefined)
insertCustomCompany.finally(() => undefined)
selectAllBigCompanies.finally(() => undefined)
customersWithDynamicCondition.finally(() => undefined)
allDataWithName.finally(() => undefined)
companiesWithCustomers.then((result) => {
    console.log('companiesWithCustomers', result)
    console.log('companiesWithCustomers resulr[0].customers', result[0]!.customers)
    console.log('companiesWithCustomers resulr[1].customers', result[1]!.customers)
})
customerWithCompany.then((result) => {
    console.log('customerWithCompany', result)
})
customerWithCompanyInOneQuery.then((result) => {
    console.log('customerWithCompanyInOneQuery', result)
})
customerWithCompanyObject.then((result) => {
    console.log('customerWithCompanyObject', result)
})
recursiveParentCompany.finally(() => undefined)
recursiveOnParentCompany.finally(() => undefined)
recursiveChildrenCompany.finally(() => undefined)
recursiveOnChildrenCompany.finally(() => undefined)
leftJoinCompany.finally(() => undefined)
customerWithIdPeaking.finally(() => undefined)
customerWithOptionalCompany.finally(() => undefined)
customerInSystemTime.finally(() => undefined)
customizedSelect.finally(() => undefined)
customizedUpdate.finally(() => undefined)
customizedDelete.finally(() => undefined)
customizedInsert.finally(() => undefined)
selectAll.finally(() => undefined)
customerWithCompanyPrefixed.then((result) => {
    console.log('customerWithCompanyPrefixed', result)
})
customerWithCompanyPrefixed2.then((result) => {
    console.log('customerWithCompanyPrefixed2', result)
})
companyPrefixed.then((result) => {
    console.log('companyPrefixed', result)
})
companyPrefixed2.then((result) => {
    console.log('companyPrefixed2', result)
})
companyPrefixed3.then((result) => {
    console.log('companyPrefixed3', result)
})
companyMultiSplit.then((result) => {
    result.map((value, i) => {
        console.log('companyMultiSplit[' + i + ']', value)
    })
})
acmeCustomers.finally(() => undefined)
deletedAcmeCompany.finally(() => undefined)
updatedSmithFirstName.finally(() => undefined)
updatedLastNames.finally(() => undefined)
insertReturningCustomerData.finally(() => undefined)
addACMECompanyNameToLastName.finally(() => undefined)
deleteACMECustomers.finally(() => undefined)

/*

PostgreSql update multitable with old values emulation:

No secondary table used in set or return

First attempt:
update customer as _new_ 
set last_name = $1 
from (
    select _old_.* 
    from customer as _old_, company 
    where _old_.company_id = company.id 
        and company.name = $2 
        and _old_.first_name = $3 
    for no key update of _old_
) as _old_ 
where _new_.id = _old_.id 
returning _old_.last_name as "oldLastName", _new_.last_name as "newLastName"

Final:
update customer as _new_ 
set last_name = $1 
from (
    select _old_.* 
    from customer as _old_, company 
    where _old_.company_id = company.id 
        and company.name = $2 
        and _old_.first_name = $3 
    for no key update of _old_
) as _old_ 
where _new_.id = _old_.id 
returning _old_.last_name as "oldLastName", _new_.last_name as "newLastName"




Secondary table used in set

First attempt:
update customer as _new_ 
set last_name = _new_.last_name || $1 || company.name 
from company, (
    select _old_.* 
    from customer as _old_, company 
    where _old_.company_id = company.id 
        and company.name = $2 
        and _old_.first_name = $3 
    for no key update of _old_, company
) as _old_ 
where _new_.id = _old_.id 
    and _new_.company_id = company.id
    and company.name = $4 
    and _new_.first_name = $5 
returning _old_.last_name as "oldLastName", _new_.last_name as "newLastName"

Final:
update customer as _new_ 
set last_name = _new_.last_name || $1 || _old_.company__name 
from (
    select _old_.*, 
           company.name as company__name 
    from customer as _old_, company 
    where _old_.company_id = company.id 
        and company.name = $2 
        and _old_.first_name = $3 
    for no key update of _old_
) as _old_ 
where _new_.id = _old_.id 
returning _old_.last_name as "oldLastName", _new_.last_name as "newLastName"



Secondary table used in return

First attempt:
update customer as _new_ 
set last_name = $1 
from company, (
    select _old_.* 
    from customer as _old_, company 
    where _old_.company_id = company.id 
        and company.name = $2 
        and _old_.first_name = $3 for 
    no key update of _old_, company
) as _old_ 
where _new_.id = _old_.id 
    and _new_.company_id = company.id 
    and company.name = $4 
    and _new_.first_name = $5 
returning _old_.last_name as "oldLastName", _new_.last_name || $6 || company.name as "newLastName"

Final:
update customer as _new_ 
set last_name = $1 
from (
    select _old_.*, 
           company.name as company__name 
    from customer as _old_, company 
    where _old_.company_id = company.id 
        and company.name = $2 
        and _old_.first_name = $3 
    for no key update of _old_
) as _old_ 
where _new_.id = _old_.id 
returning _old_.last_name as "oldLastName", _new_.last_name || $4 || _old_.company__name as "newLastName"

*/

// case when then end
// agragate functions, group by, having
// begin transaction, commit, rollback
// return last inserted id
// with, with recursive
// from select
// window, over
// insert multiple
// union, intersect
// call stored procedure

// functions: coalesce, ifnull, min, max, nullIf <-- implentadas como valueWhenNull, minValue, maxValue, excepto nullIf
// maths: acosh-, asinh-, atanh-, difference(descartar), degrees-, radians-, cosh-, sinh-, tanh-, coth-,
// string: repeat(replicate) [no oracle], indexof(strpos, charindex) [difiere el resultado cuando no lo encuentra],
//         left(leftstr) [no disponible en oracle, usar substring], right(rightstr) [no disponible en oracle, usar substring]
//         lpad(padl) [no disponible en sql server], rpad(padr) [no disponible en sql server], padc?-,

// order by null first, last


/*
            returning   lastInsertedId  sequence
MariaDB     no          yes             no
MySql       no          yes             no
Oracle      yes*        no              yes
Postgre     yes         no              yes
Sqlite      no          yes             no
Sqlserver   yes         no              yes

   * It doesn't work when you insert multiple rows
*/

/*
Things that I want to implement:
+ return last inserted id
+ begin transaction, commit, rollback
+ call stored procedure
+ sequences
+ order by null first, last: https://stackoverflow.com/questions/12503120/how-to-do-nulls-last-in-sqlite https://nickstips.wordpress.com/2010/09/30/sql-order-by-with-null-values-last/
+ sql fragments

2nd to implement:
+ basic agragate functions
+ group by
+ having

3rd to implement:
+ insert multiple
+ insert from select

4th to implement:
+ with
+ with recursive
+ union, intersect

5th to implement:
+ returning

6th to implement:
+ update multiple from

Things that I don't want to implement by now
- agregate functions: filter
- agregate functions: order by
- window, over
- complex agragate functions

Things that probably I'm not going to implement due alternative syntax exists:
- from select

Links:
- Sqlite bug update returning: https://sqlite.org/forum/forumpost/e70ea1b15f
- Modern SQL: https://modern-sql.com
- Pagination with Relative Cursors: https://shopify.engineering/pagination-relative-cursors
- Online test: https://sqliteonline.com/

Documentation:
- PostgreSql: https://www.postgresql.org/docs/13/sql-delete.html
- SqlServer: https://docs.microsoft.com/es-es/sql/t-sql/statements/delete-transact-sql?view=sql-server-ver15
- Sqlite: https://www.sqlite.org/index.html
- MySql: https://dev.mysql.com/doc/refman/8.0/en/delete.html
- MariaBD: https://mariadb.com/kb/en/delete/
- Oracle SQL Language refernec: https://docs.oracle.com/en/database/oracle/oracle-database/21/sqlrf/DELETE.html#GUID-156845A5-B626-412B-9F95-8869B988ABD7
- Oracle PL/SQL Langage reference: https://docs.oracle.com/en/database/oracle/oracle-database/21/lnpls/DELETE-statement-extension.html#GUID-9BEEC5E0-EF77-4E88-9DD4-B9BA1EABABCF
- Oracle 11g Database Advanced Application Developer's Guide: https://docs.oracle.com/cd/B28359_01/appdev.111/b28424/adfns_flashback.htm#g1026131
- Oracle 11g Database PL/SQL Language Reference: https://docs.oracle.com/database/121/LNPLS/langelems.htm#LNPLS013

Others:
- Join-Monster: https://join-monster.readthedocs.io/en/latest/
*/